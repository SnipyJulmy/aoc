%!PS
% Advent of Code 2025 - Day 05

% Dynamic Array implementation

% usage: /myArray Dynarray.init def
/Dynarray.init {
  4 dict begin
    /Capacity 128 def
    /Size 0 def
    /Data Capacity array def
    currentdict
  end
} def

% usage : /size myArray Dynarray.size def
/Dynarray.size {
  begin
    Size
  end
} def

% usage : myArray element Dynarray.append
/Dynarray.append {
  exch 
  begin
    /elt exch def
    Size Capacity ge {
      /Capacity Capacity 2 mul def
      /New Capacity array def
      New 0 Data putinterval
      /Data New def
    } if
    Data Size elt put
    /Size Size 1 add def
  end
} def

% usage : myArray idx Dynarray.get
/Dynarray.get {
  exch
  begin
    Data exch get
  end
} def

% usage : myArray idx value Dynarray.set
/Dynarray.set {
  /value exch def
  /idx exch def
  begin
    Data idx value put
  end
} def

% usage : myArray Dynarray.print
/Dynarray.print {
  begin
    ([) print
    0 1 Size 1 sub {
      Data exch get Range.print
    } for
    (]) print
    (DEBUG) ==
  end
} def

% usage : myArray {lambda} base Dynarray.foldleft
% lambda : acc elt on the stack
% return : acc
/Dynarray.foldleft {
  /acc exch def
  /lambda exch def
  begin
    0 1 Size 1 sub {
      Data exch get
      acc exch
      lambda
      /acc exch def
    } for
  acc
  end
} def

% usage myArray { compare : x y -> {-1,0,1} } Dynarray.sort
/Dynarray.sort {
  /compare exch def
  /array exch def
  0 1 array Dynarray.size 2 sub {
    dup /min exch def
    /i exch def
    i 1 array Dynarray.size 1 sub {
      /j exch def
      array i Dynarray.get array j Dynarray.get compare
      0 lt { /min j def } if
      (min is ) print array min Dynarray.get Range.start ==
    } for
    () ==
    () ==
    i min ne { array i min Dynarray.swap} if
  } for
} def

% usage : array x y Dynarray.swap
/Dynarray.swap {
  /y exch def
  /x exch def
  begin
    /tmp Data x get def
    Data x Data y get put
    Data y tmp put
  end
} def

% --- Range - data structure
% usage /myRange start end Range.init def
/Range.init {
  2 dict begin
    /End exch def
    /Start exch def
    currentdict
  end
} def

/Range.start {
  begin
    Start
  end
} def

% usage myRange n Range.isIn
/Range.isIn {
  exch
  begin
    dup Start ge
    exch
    End le
    and
  end
} def

% usage myRange Range.print
/Range.print {
  /buf 20 string def
  begin
    ([) print
    Start buf cvs print
    (-) print
    End buf cvs print
    (]) print
  end
} def

% --- Range - end

% Font config
/Courier findfont 12 scalefont setfont

% open file and store content
/InputFile where { pop } { /InputFile (../inputs/day05-example.txt) def } ifelse
/Stream InputFile (r) file def
/ReadBuffer 1024 string def

/ranges Dynarray.init def
/ids Dynarray.init def

{
  Stream ReadBuffer readline
  not { pop exit} if
  dup length 0 le { pop exit } if

  (-) search % this split the string in two
  {
    cvi 3 1 roll pop cvi
    ranges 3 1 roll
    Range.init
  } if
  ranges exch Dynarray.append
  pop
} loop


{
  Stream ReadBuffer readline
  not { pop exit} if
  cvi
  ids exch Dynarray.append
} loop


/score1 ids { % acc elt ->
  /elt exch def
  /sum exch def
  0 1 ranges Dynarray.size 1 sub {
    ranges exch Dynarray.get
    elt Range.isIn
    { /sum sum 1 add def exit } if
  } for
  sum
} 0 Dynarray.foldleft def

ranges Dynarray.print
ranges {
  Range.start exch Range.start sub
} Dynarray.sort

ranges Dynarray.print

/score2 1 def

score1 ==
score2 ==

50 750 moveto
(Advent of Code 2025 - Day 05) show

/buffer 20 string def

50 720 moveto
(Part 1: ) show
score1 buffer cvs show

50 700 moveto
(Part 2: ) show
score2 buffer cvs show

showpage
