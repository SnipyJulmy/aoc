%!PS
% Advent of Code 2025 - Day 05

% max function keep the greatest number on the stack
/max { 2 copy lt { exch } if pop } def

%%% Dynamic Array implementation

% usage: /myArray Dynarray.init def
/Dynarray.init {
  4 dict begin
    /Capacity 128 def
    /Size 0 def
    /Data Capacity array def
    currentdict
  end
} def

% usage : /size myArray Dynarray.size def
/Dynarray.size {
  begin
    Size
  end
} def

% usage : myArray element Dynarray.append
/Dynarray.append {
  exch 
  begin
    /elt exch def
    Size Capacity ge {
      /Capacity Capacity 2 mul def
      /New Capacity array def
      New 0 Data putinterval
      /Data New def
    } if
    Data Size elt put
    /Size Size 1 add def
  end
} def

% usage : myArray idx Dynarray.get
/Dynarray.get {
  exch
  begin
    Data exch get
  end
} def

% usage : myArray idx value Dynarray.set
/Dynarray.set {
  /value exch def
  /idx exch def
  begin
    Data idx value put
  end
} def

% usage : myArray {lambda} base Dynarray.foldleft
% lambda : acc elt on the stack
% return : acc
/Dynarray.foldleft {
  /Dynarray.foldleft.acc exch def
  /Dynarray.foldleft.lambda exch def
  begin
    0 1 Size 1 sub {
      Data exch get
      Dynarray.foldleft.acc exch
      Dynarray.foldleft.lambda
      /Dynarray.foldleft.acc exch def
    } for
  Dynarray.foldleft.acc
  end
} def

% usage myArray { compare : x y -> {-1,0,1} } Dynarray.sort
/Dynarray.sort {
  /compare exch def
  /array exch def
  0 1 array Dynarray.size 2 sub {
    dup /min exch def
    /i exch def
    i 1 array Dynarray.size 1 sub {
      /j exch def
      array min Dynarray.get array j Dynarray.get compare
      0 gt { /min j def } if
    } for
    i min ne { array i min Dynarray.swap} if
  } for
} def

% usage : array x y Dynarray.swap
/Dynarray.swap {
  /y exch def
  /x exch def
  begin
    /tmp Data x get def
    Data x Data y get put
    Data y tmp put
  end
} def

% --- Range - data structure
% usage /myRange start end Range.init def
/Range.init {
  2 dict begin
    /End exch def
    /Start exch def
    currentdict
  end
} def

/Range.start {
  begin
    Start
  end
} def

/Range.end {
  begin
    End
  end
} def

% usage myRange n Range.isIn
/Range.isIn {
  exch
  begin
    dup Start ge
    exch
    End le
    and
  end
} def

% usage : r1 r2 Range.compare ->
% negative number if r1 < r2
% positive number if r1 > r2
% zero            if r1 = r2
/Range.compare {
  exch Range.start exch Range.start sub
} def

% --- Range - end

% open file and store content
/InputFile where { pop } { /InputFile (../inputs/day05-example.txt) def } ifelse
/Stream InputFile (r) file def
/ReadBuffer 1024 string def

/ranges Dynarray.init def
/ids Dynarray.init def

{
  Stream ReadBuffer readline
  not { pop exit} if
  dup length 0 le { pop exit } if

  (-) search % this split the string in two
  {
    cvi 3 1 roll pop cvi
    ranges 3 1 roll
    Range.init
  } if
  ranges exch Dynarray.append
  pop
} loop


{
  Stream ReadBuffer readline
  not { pop exit} if
  cvi
  ids exch Dynarray.append
} loop

/score1 ids { % acc elt ->
  /elt exch def
  /sum exch def
  0 1 ranges Dynarray.size 1 sub {
    ranges exch Dynarray.get
    elt Range.isIn
    { /sum sum 1 add def exit } if
  } for
  sum
} 0 Dynarray.foldleft def

ranges { Range.compare } Dynarray.sort

/buffer 20 string def
/current ranges 0 Dynarray.get Range.start def

/score2 ranges { % acc elt ->
  /elt exch def
  /acc exch def

  /Start elt Range.start def
  /End elt Range.end def
  /EffStart Start current 1 add max def
  End EffStart ge {
    /len End EffStart sub 1 add def
    /acc acc len add def
    /current End def
  } if
  acc
} 1 Dynarray.foldleft def

% Font config
/Courier findfont 12 scalefont setfont

50 750 moveto
(Advent of Code 2025 - Day 05) show

50 720 moveto
(Part 1: ) show
score1 buffer cvs show

50 700 moveto
(Part 2: ) show
score2 buffer cvs show

showpage
